## Introduction to Akka(2.5.4)
- 原文链接：[http://doc.akka.io/docs/akka/current/java/guide/introduction.html](http://doc.akka.io/docs/akka/current/java/guide/introduction.html "http://doc.akka.io/docs/akka/current/java/guide/introduction.html")

### How to get started

如果这是你第一次使用 Akka，我们建议你先从运行一个简单的 Hello World 项目开始。有关下载和运行 Hello World 示例的说明，请参考“Quickstart Guide”。“Quickstart guide” 通过示例代码引导你如何定义 actor system，actor，message，如何使用测试模块和日志记录。在 30 分钟内，你应该就可以运行 Hello World 示例，还有了解期构建方式。

本入门指南提供下更深层次的信息。涵盖了为什么 actor 模型符合现代分布式系统的需求，并包括一个有助于帮助你进一步了解 Akka 的教程。主题包括：

- 为什么现代的系统需要一个新的编程模型；
- actor 模型如何满足并发、分布式系统的需求；
- Akka 库和模块的概述；
- 在 Hello World 示例上，构建一个更复杂的例子来说明常见的 Akka 模式；

## Why modern systems need a new programming model

actor 模型在几十年前被 **Carl Hewitt** 提出，作为在高性能网络并行处理的一种方法 -- 在当时没有这种环境。今天，硬件和基础设施的能力已经超过 **Hewitt** 的愿景。因此，组织构建具有苛刻要求的分布式系统，是传统的面向对象编程（OOP）无法完全解决的挑战，但是可以从 actor 模型中获益。（意思就是传统的面向对象编程，无法满足构建苛刻要求的分布式系统，但是 actor 模型却可以）

今天，actor 模式不仅被公认为高效的解决反感 -- 在世界最苛刻的应用中，被证明是可行的。为了突出 actor 模型解决问题的能力，本主题讨论了传统编程和现代多线程模型，多 cpu 架构，之间的不匹配（意思就是传统的编程，不能匹配现代多线程、多 cpu 的架构，不能够完全利用多 cpu 架构的优势）：

- 封装的挑战
- 共享内存在现代计算机架构的错觉（the illusion of 翻译为了错觉，这里有点怪怪）
- 调用堆栈的错觉

### The challenge of encapsulation

面向对象编程一个核心就是**封装**。封装规定对象内部数据不能直接被外部访问；它只能通过调用一些方法来修改。对象负责安全的暴露一些操作，保护其封装的数据的不变性。（意思就是，对象对数据的安全负责，仅仅暴露一些安全的操作）

例如，对有序二叉树实现的操作，得确保树的顺序性。调用这期望顺序是完整的，当查询书的某一个数据时，他们需要能够依赖这个约束。

当我们分析一个 oop 运行是的行为时，我们有事会绘制一个消息序列图，来显示方法调用的交互。例如：

不幸的是，上面的图不能准确代表实例执行的生命线。实际上，一个线程会执行所有调用，同一个线程调用这些方法是不变的。所以更新线程执行调用的图（这里中文表述有点怪）：

当你尝试多个线程发生情况进行建模是，此澄清的意义将变得清晰。突然，我们之前画的图变得不足已描述情况。我们可以尝试阐述多个线程访问同一个实例：

（目前为止，说的就是，传统的面向对象编程在多线程模型中，有许多不足，例如对同一个实例进行访问的时候，也就是实际需要考虑的线程安全问题）

有两个线程进入了同一个方法。不幸的是，对象的封装性不能保证这部分会发生什么。两个调用的指令可以以任意方式进行交织，如果没有两个线程之间的一些协调，那么保存不变量（这里说的应该是，可以确定的量，可以预料的值）变得无望（也就是说，除非自己做一些线程的协调，不然没有办法保证原本可以预料的量）。现在，想象这个问题会由于更多的线程而变得更加的复杂。

解决这个问题的常见方法，是给这些方法添加锁。虽然这样可以最多只有一个线程进入该方法，但是这种策略非常昂贵（也就是会让其他线程进入阻塞）：

- 锁严重限制了并发，对于现代 CPU 架构而言，这样显得非常消耗（原来有的优势，没有用好优势），需要从操作系统挂起线程然后恢复。
- 调用线程现在被阻塞，所以它不能做任何事。即使是桌面应用程序也是不能被接受的，即使长时间的后台任务在运行，我们也希望让UI部分继续响应。在后台，阻塞是完全浪费的。人们认为可以通过启动新的线程来补偿，但是线程也是挺大消耗。
- 锁会引起一个新的威胁：死锁。

这些情况导致了 no-win 的局面：

- 没有足够的锁，那么状态可能会被破坏；
- 如果有许多锁，性能下降，也容易导致死锁；

另外，锁只能在本地运行得很好。当谈到跨多物理机的协调，唯一的选择是分布式锁。不幸的是，分布式锁的几个数值比本地锁的效率低，通常会对拓展产生限制。分布式锁协议需要在多台机器上通过网络多次往返，也就会造成延迟。

在面向对象的编程语言里，我们一般很少想到有关线程的或线程执行路径。我们经常设想一个系统作为一个网络，对对象实例的调用做出反应，修改他们的内部状态，然后通过方法调用驱动整个系统的状态，来相互通信：

然而，在多线程分布式环境中，实际发生的是线程“遍历”网络中的对象实例，通过一下方法调用。因此，线程是真正的驱动执行：

综上所述：






