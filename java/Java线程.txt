
2018.03.14

        关于线程：

            线程的变量（访问的对象）内存是哪块区域（应该是在Java堆），所以它对所有线程可见，所有可能会引起多线程竞争的情况，如果多个线程访问同一个对象，那么会引起不确定的结果。

            因为线程在改变对象的值的时候，是先把变量的值复制到工作内存，然后进行逻辑处理，处理完之后，再把值传回主内存，所以多个线程操作，结果是不可预见的。

            可以通过 synchronized 来进行同步操作，加上之后，对对象的改变的结果，会变得马上可见，其它线程在操作该值的时候，是实时的值。或者通过 volatile 修饰符。或者通过加锁 Lock 实现。

            有没有什么办法是可以不通过加锁来实现多线程访问，并保证安全的。

            无同步方案（见《深入理解Java虚拟机：JVM高级特性与最佳实践》13章

            可重入代码：也叫做纯代码；
            线程本地存储：ThreadLocal

            线程安全的实现方法（见《深入理解Java虚拟机：》13.2.2

            1. 互斥同步：临界区，互斥量，信号量都是主要的互斥实现方法；Java最基本的手段就是 synchronized 关键字，ReentrantLock 重入锁；

            非阻塞同步
                互斥同步最主要的问题，就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。互斥同步属于一种悲观的并发策略；

                有另外一个选择：基于冲突检测的乐观并发策略，通俗的讲，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突（这种的前途，是系统提供了接口，放我们可以检测是不是产生了冲突），那就再采取其他的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作也成为非阻塞同步。

                需要一条处理器指令就能完成，为什么？因为如果不是，这中间如果被执行其他的，就会破坏同步效果


                …… 接下去可以整理，线程池，还有 CAS 的东西，所有东西，都需要刨根问底,刨根问底,刨根问底,刨根问底