## C 调用 Lua 函数 ##

- 参考文档：www.luachina.net 翻译组在 2005 年基于 Lua5.0 翻译的 《Lua程序设计.chm》
- 开发环境：
 - 操作系统：64 位 CentOS release 6.6 (Final)
 - Lua 版本：Lua 5.2.2
 - 编译器  ：GCC 4.4.7

上代码前先了解下几个接口：

- `void lua_getglobal (lua_State *L, const char *name)`

官网文档是这么“Pushes onto the stack the value of the global name”描述的。意思就是把 name 对应的全局变量的值放到栈顶，这里“全局变量”翻译，总感觉怪怪的。Lua 有 8 种基本类型：nil、boolean、number、string、userdata、function、thread和table。

- `void lua_call (lua_State *L, int nargs, int nresults);`

To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call lua\_call; nargs is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to nresults, unless nresults is LUA_MULTRET. In this case, all results from the function are pushed. Lua takes care that the returned values fit into the stack space. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.

调用这个函数必须遵循下面的规则：首先，要调用的函数压入栈顶；然后函数相应的参数按顺序压入栈顶；也就是第一个参数首先压入；最后调用 `lua_call`；nargs 为你压入栈的参数的个数。所有的参数和函数在调用完之后，会被移出栈。函数返回的时候，会把函数结果压入栈顶。结果的个数跟据 nresults 调整，除非 nresults 是 LUA_MULTRET。这种情况，所有的结果都会被压入栈顶。Lua takes care that the returned values fit into the stack space.函数结果被有序的压入栈（第一个结果首先被压入），所以在调用完之后，最后一个结果在栈顶。

- `int lua_pcall (lua_State *L, int nargs, int nresults, int msgh)`

Calls a function in protected mode.

Both nargs and nresults have the same meaning as in lua\_call. If there are no errors during the call, lua\_pcall behaves exactly like lua\_call. However, if there is any error, lua\_pcall catches it, pushes a single value on the stack (the error message), and returns an error code. Like lua\_call, lua_pcall always removes the function and its arguments from the stack.

If msgh is 0, then the error message returned on the stack is exactly the original error message. Otherwise, msgh is the stack index of a message handler. (In the current implementation, this index cannot be a pseudo-index.) In case of runtime errors, this function will be called with the error message and its return value will be the message returned on the stack by lua_pcall.

Typically, the message handler is used to add more debug information to the error message, such as a stack traceback. Such information cannot be gathered after the return of lua_pcall, since by then the stack has unwound.

The lua_pcall function returns one of the following codes (defined in lua.h):

- LUA_OK (0): success.
- LUA_ERRRUN: a runtime error.
- LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the message handler.
- LUA_ERRERR: error while running the message handler.
- LUA_ERRGCMM: error while running a __gc metamethod. (This error typically has no relation with the function being called. It is generated by the garbage collector.)

在保护模式下调用函数。

nargs 和 nresults 这两个参数对于函数 `lua_pcall` 意义是一样的。如果在调用过程中没有错误，那么 `lua_call` 和 `lua_pcall` 几乎是一样的。 然而如果有错误，lua\_pcall 会捕捉这个错误，并压入一个信号值到栈顶（错误信息），然后返回错误码。和 `lua_call` 一样，`lua_pcall` 总会在调用完把函数和参数从栈顶移除。

如果 msgh 为 0，那么返回到栈顶的错误信息是原始的错误信息。不然，msgh 为处理消息函数的栈索引（现有实现，index 不能是伪索引）。运行错误的情况下，该函数会被 `lua_pcall` 调用，参数是错误信息字符串，返回的信息放在栈顶。

通常，message 处理函数被用来增加调试信息，譬如栈回溯。这些信息在 lua_pcall 返回后不能被获取，因为那个时候栈 has unwound。

函数 lua_pcall 返回下面的某一个值：

- LUA_OK(0)  ：成功
- LUA_ERRRUN ：运行错误
- LUA_ERRMEM ：内存分配错误。这个错误，Lua 不会调用错误处理函数。
- LUA_ERRERR ：运行错误处理函数出错。
- LUA_ERRGCMM：运行 __gc metamathod 错误。(这错误通常和该函数被调用没关系。是由“垃圾回收器”产生的)

### 直接上代码 ###
#### C 代码 l\_25\_2.c ####
	#include <lua.h>
	#include <lauxlib.h>
	#include <stdio.h>
	
	double f (lua_State *L, double x, double y) {
	    lua_getglobal(L, "f");
	    lua_pushnumber(L, x);
	    lua_pushnumber(L, y);
	
	    double z = -1;
	    if (0 != lua_pcall(L, 2, 1, 0)) {
	        fprintf(stderr, "%s", lua_tostring(L, -1));
	    } else if (!lua_isnumber(L, -1)){
	        fprintf(stderr, "function 'f' must return a number");
	    } else {
	        z = lua_tonumber(L, -1);
	    }
	    lua_pop(L, 1);  //lua 会把结果压入栈顶，所以调用完之后，要把结果从栈弹出
	    return z;
	}
	
	int main(void) {
	    lua_State *L = luaL_newstate();
	    luaL_openlibs(L);
	    luaL_dofile(L, "add.lua");
	
	    printf("%f", f(L, 2.9, 3.2));
	
	    lua_close(L);
	}

#### Lua 代码 add.lua ####
	function f (x, y)
	    return (x^2 * math.sin(y))/(1 - x)
	end